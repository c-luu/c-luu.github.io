---
layout: post
title:  "TDD with Category Partition method"
date:   2017-06-30 23:17:12 +0000
categories: [QA]
tags: [testing, tdd]
---

### Intro
Given the entire input domain for a function, failures in testing are generally sparse. It is common to find more failure density in sub-domains, or partitions of the input domain. These partitions are _natural_ areas of the domain that are treated homogeneously by the program.

Failures are usually dense in these partitions so we can take advantage by doing the following: 

1. Identify partitions
2. Select inputs from each partition

By using the above approach we can increase our chances to reveal faulty code as opposed to selecting random inputs from the domain to test.

### Example
Below, we have a self explanatory split method- how do we identify the partitions here?

{% highlight bash%}
split(string str, int size)
{% endhighlight %}

We _could_ identify input size as partitions, i.e.:
* size < 0
* size = 0
* size > 0

And for the _str_ parameter we can consider the following partitions:
* _str_ with length < size
* _str_ with length in [size, size x 2]
* _str_ with length > size x 2

Now that we have selected our partitions, or sub-domains, we move to the second step. Here, the basic idea is that errors tend to occur at the _boundary_ of a sub-domain. As a result, it's helpful to select inputs at these boundaries. 

Here's some selected inputs based on the boundary strategy:
* size = -1
* size = 1
* size = MAXINT
* _str_ with length size - 1
* _str_ with length size
* etc.

With these steps defined we can move to specifying our test cases (ignore the sub-domains for now).

### Test Case Specs
We can take the [Cartesian product][cartesian] of the selected inputs for _str_ and _size_, i.e.: 
* size = -1, _str_ with length -2
* size = -1, _str_ with length -1
* size = 1, _str_ with length 0
* and so on

As you can see, some of these test cases don't make sense. It's not possible to have a string with a negative length. To more effectively produce test cases without cases that don't make sense, we'll examine the _category partition method_ that creates test cases from specs using six steps. 

### Category Partition
Given specifications:
1. Identify independently testable features
2. Identify categories
3. Partition categories into choices
4. Identify constraints among choices
5. Produce/ evaluate test case specs
6. Generate test cases from test case specs

The two key steps are steps two and three, hence the derived name of the method. We will break down each step, starting with step two, below:

### Identify categories
For this step we need to define the characteristics of each input element. Given our domain knowledge, we can characterize _str_ and size:

| input str | input size |
|-----------|------------|
| length    | value      |
| content   |            |

### Partition categories into choices
For this step we identify interesting cases, or sub-domains in our split method.

| input str | input size |
|-----------|------------|
| length (0, size - 1, etc.) | value (0, > 0, < 0, MAXINT, etc.) |
| content (spaces, special characters) |            |

### Identify constraints among choices
This step is necessary to eliminate meaningless combos and to reduce number of test cases. There's three properties to consider:

1. Property ...If
2. Error (when considering combos of possible choices, we'll only consider this once)
3. Single (use when limiting test cases, similar to _error_, this choice will only be used in one combination)

| input str | input size |
|-----------|------------|
| length (0: __property zerovalue__, size - 1, etc.) | value (0, > 0, < 0: __error__, MAXINT: __single__, etc.) |
| content (spaces, special characters: __if !zerovalue__) |            |

### Produce and evaluate test case specs
This is an automated step used to produce a set of _test frames_, which is just a spec of a test. 

An example of a test frame:

{% highlight bash%}
Test frame #36
    input str
        length: size - 1
        content: special chars
    input size 
        value: > 0
{% endhighlight %}

In the frame, labeled by a sequence number, and some specs for our two input variables. This is just one permutation of many auto-generated frames. We can reduce the quantity of frames generated by introducing more constraints.

### Generate test cases from test case specs
In this step we instantiate the frames to produce a set a concrete tests. An example concrete test would be:

{% highlight bash%}
Test frame #36
    str = "abCC!*"
    size = 10
{% endhighlight %}

This leaves us with one permutation of a unit test generated from this method.

### References
* [GT Software Development Processes](https://classroom.udacity.com/courses/ud805/lessons/3626359166/concepts/5198585680923)
[cartesian](https://en.wikipedia.org/wiki/Cartesian_product)

